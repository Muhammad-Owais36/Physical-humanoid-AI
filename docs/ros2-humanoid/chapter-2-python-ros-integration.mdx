---
sidebar_position: 2
---

# Chapter 2: Connecting Python AI Agents with rclpy

## Introduction

Python has become the dominant language for artificial intelligence development, with rich ecosystems for machine learning, computer vision, and natural language processing. However, robotic systems traditionally use C++ for performance-critical real-time control. The **rclpy** library bridges this gap, enabling Python AI agents to seamlessly integrate with ROS 2-based humanoid robots.

This chapter explores how to connect Python-based AI systems to ROS 2 controllers using rclpy, creating an AI-to-ROS control bridge that enables intelligent robotic behaviors.

## Understanding rclpy

**rclpy** is the Python client library for ROS 2, providing Python bindings for ROS 2's communication primitives. It allows Python programs to:

- Create and manage ROS 2 nodes
- Publish and subscribe to topics
- Call and provide services
- Use actions for goal-oriented communication
- Access ROS 2 parameters and logging systems

### Installation and Setup

To use rclpy, you need a ROS 2 installation (Humble Hawksbill or Iron Irwini):

```bash
# Install ROS 2 Python client library
# rclpy is included with ROS 2 installations
import rclpy
from rclpy.node import Node
```

### Basic Node Structure

All rclpy applications start with node initialization:

```python
import rclpy
from rclpy.node import Node

class PythonAIAgent(Node):
    def __init__(self):
        super().__init__('python_ai_agent')
        self.get_logger().info('Python AI Agent initialized')

def main(args=None):
    rclpy.init(args=args)
    ai_agent = PythonAIAgent()

    try:
        rclpy.spin(ai_agent)
    except KeyboardInterrupt:
        pass
    finally:
        ai_agent.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Creating Publishers

Publishers enable Python AI agents to send commands to ROS 2 systems. This is essential for translating AI decisions into robot actions.

```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String
from trajectory_msgs.msg import JointTrajectory

class AIPublisher(Node):
    def __init__(self):
        super().__init__('ai_publisher')

        # Publisher for simple commands
        self.command_publisher = self.create_publisher(
            String,
            'ai_commands',
            10
        )

        # Publisher for complex trajectories
        self.trajectory_publisher = self.create_publisher(
            JointTrajectory,
            '/joint_trajectory_controller/joint_trajectory',
            10
        )

        # Timer to send commands periodically
        self.timer = self.create_timer(1.0, self.send_command)

    def send_command(self):
        # Example: Send a simple command
        msg = String()
        msg.data = 'Move to position A'
        self.command_publisher.publish(msg)

        # Example: Send a trajectory command
        trajectory = self.generate_trajectory()
        self.trajectory_publisher.publish(trajectory)

    def generate_trajectory(self):
        # Generate trajectory based on AI decision
        trajectory = JointTrajectory()
        # ... trajectory generation logic
        return trajectory
```

## Creating Subscribers

Subscribers allow Python AI agents to receive sensor data and other information from the robot system:

```python
from sensor_msgs.msg import JointState, Imu
from geometry_msgs.msg import Twist

class AISubscriber(Node):
    def __init__(self):
        super().__init__('ai_subscriber')

        # Subscribe to joint states
        self.joint_subscriber = self.create_subscription(
            JointState,
            '/joint_states',
            self.joint_state_callback,
            10
        )

        # Subscribe to IMU data
        self.imu_subscriber = self.create_subscription(
            Imu,
            '/imu/data',
            self.imu_callback,
            10
        )

        # Store latest sensor data
        self.latest_joint_states = None
        self.latest_imu_data = None

    def joint_state_callback(self, msg):
        self.latest_joint_states = msg
        self.get_logger().info(f'Received {len(msg.position)} joint positions')
        # Process joint data for AI decision making

    def imu_callback(self, msg):
        self.latest_imu_data = msg
        # Process IMU data for balance/pose estimation
```

## The AI-to-ROS Control Bridge

The AI-to-ROS control bridge connects high-level AI decisions with low-level robot control. This architecture typically follows a pattern:

1. **AI Decision Making**: Process sensor data and make high-level decisions
2. **Command Generation**: Convert decisions into ROS 2 messages
3. **Command Execution**: Publish commands to appropriate ROS 2 topics
4. **Feedback Processing**: Monitor results and adjust behavior

```python
import rclpy
from rclpy.node import Node
import numpy as np
from sensor_msgs.msg import JointState
from trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint
from builtin_interfaces.msg import Duration

class AIControlBridge(Node):
    def __init__(self):
        super().__init__('ai_control_bridge')

        # Subscribers for sensor data
        self.sensor_subscriber = self.create_subscription(
            JointState,
            '/joint_states',
            self.sensor_callback,
            10
        )

        # Publishers for commands
        self.command_publisher = self.create_publisher(
            JointTrajectory,
            '/joint_trajectory_controller/joint_trajectory',
            10
        )

        # Store robot state
        self.current_joint_positions = {}

        # AI processing timer
        self.ai_timer = self.create_timer(0.1, self.ai_processing_loop)

    def sensor_callback(self, msg):
        # Update current joint positions
        for i, name in enumerate(msg.name):
            if i < len(msg.position):
                self.current_joint_positions[name] = msg.position[i]

    def ai_processing_loop(self):
        # Get current state
        current_state = self.get_current_state()

        # AI decision making (simplified example)
        desired_action = self.ai_decision(current_state)

        # Convert AI decision to ROS command
        trajectory = self.convert_to_trajectory(desired_action)

        # Publish command
        self.command_publisher.publish(trajectory)

    def get_current_state(self):
        # Extract relevant state information for AI
        state = {
            'joint_positions': self.current_joint_positions,
            # Add other relevant state information
        }
        return state

    def ai_decision(self, state):
        # Placeholder for AI logic
        # In practice, this could involve:
        # - Neural network inference
        # - Planning algorithms
        # - Reinforcement learning policies
        action = {
            'target_positions': [0.1, 0.2, 0.3],  # Example joint positions
            'duration': 1.0  # Move duration in seconds
        }
        return action

    def convert_to_trajectory(self, action):
        trajectory = JointTrajectory()
        trajectory.joint_names = ['joint_1', 'joint_2', 'joint_3']  # Replace with actual joint names

        point = JointTrajectoryPoint()
        point.positions = action['target_positions']
        point.velocities = [0.0] * len(action['target_positions'])  # Zero velocity at target
        point.time_from_start = Duration(sec=int(action['duration']), nanosec=0)

        trajectory.points = [point]
        return trajectory
```

## Example: Sending Motion Commands

Here's a practical example of an AI agent sending motion commands to a humanoid robot:

```python
import rclpy
from rclpy.node import Node
import random
from trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint
from builtin_interfaces.msg import Duration

class MotionCommandAI(Node):
    def __init__(self):
        super().__init__('motion_command_ai')

        # Publisher for joint trajectories
        self.trajectory_publisher = self.create_publisher(
            JointTrajectory,
            '/joint_trajectory_controller/joint_trajectory',
            10
        )

        # Timer to send periodic motion commands
        self.motion_timer = self.create_timer(2.0, self.send_motion_command)

        # Define joint names for the humanoid
        self.joint_names = [
            'left_hip_joint', 'left_knee_joint', 'left_ankle_joint',
            'right_hip_joint', 'right_knee_joint', 'right_ankle_joint',
            'left_shoulder_joint', 'left_elbow_joint', 'left_wrist_joint',
            'right_shoulder_joint', 'right_elbow_joint', 'right_wrist_joint'
        ]

    def send_motion_command(self):
        trajectory = JointTrajectory()
        trajectory.joint_names = self.joint_names

        # Generate random motion (in practice, this would be intelligent)
        point = JointTrajectoryPoint()

        # Random joint positions within safe limits
        target_positions = []
        for _ in range(len(self.joint_names)):
            pos = random.uniform(-0.5, 0.5)  # Safe range in radians
            target_positions.append(pos)

        point.positions = target_positions
        point.velocities = [0.0] * len(target_positions)
        point.accelerations = [0.0] * len(target_positions)
        point.time_from_start = Duration(sec=1, nanosec=0)

        trajectory.points = [point]

        self.trajectory_publisher.publish(trajectory)
        self.get_logger().info(f'Sent motion command to {len(self.joint_names)} joints')
```

## Error Handling and Robustness

Python AI agents must handle various failure modes in robotic systems:

```python
class RobustAIAgent(Node):
    def __init__(self):
        super().__init__('robust_ai_agent')

        # Initialize communication components
        self.trajectory_publisher = self.create_publisher(
            JointTrajectory,
            '/joint_trajectory_controller/joint_trajectory',
            10
        )

        # Timer for periodic health checks
        self.health_timer = self.create_timer(5.0, self.health_check)

    def health_check(self):
        try:
            # Check if publisher is still active
            if self.trajectory_publisher:
                self.get_logger().debug('Trajectory publisher active')
        except Exception as e:
            self.get_logger().error(f'Publisher error: {e}')
            # Implement recovery strategy

    def safe_publish(self, msg):
        try:
            self.trajectory_publisher.publish(msg)
        except Exception as e:
            self.get_logger().error(f'Failed to publish message: {e}')
            # Implement fallback behavior
```

## Integration with Machine Learning Frameworks

rclpy integrates seamlessly with popular Python ML frameworks:

```python
import rclpy
from rclpy.node import Node
import tensorflow as tf  # or torch for PyTorch
import numpy as np

class MLIARobot(Node):
    def __init__(self):
        super().__init__('ml_ai_robot')

        # Load pre-trained model
        self.model = self.load_model()

        # Set up ROS communication
        self.sensor_subscriber = self.create_subscription(
            JointState,
            '/joint_states',
            self.ml_processing_callback,
            10
        )

        self.command_publisher = self.create_publisher(
            JointTrajectory,
            '/joint_trajectory_controller/joint_trajectory',
            10
        )

    def load_model(self):
        # Load your trained ML model
        # model = tf.keras.models.load_model('path/to/model')
        # or use PyTorch, scikit-learn, etc.
        pass

    def ml_processing_callback(self, msg):
        # Convert sensor data to format expected by ML model
        sensor_data = np.array(msg.position)

        # Run inference
        action = self.model.predict(sensor_data.reshape(1, -1))

        # Convert ML output to ROS command
        trajectory = self.ml_action_to_trajectory(action[0])

        # Publish command
        self.command_publisher.publish(trajectory)
```

## Best Practices

1. **Use appropriate QoS profiles** for different message types
2. **Implement proper error handling** for robust operation
3. **Consider timing requirements** for real-time control
4. **Validate commands** before sending to prevent dangerous movements
5. **Log important events** for debugging and analysis
6. **Use parameters** for configurable behavior

## Summary

The rclpy library enables powerful integration between Python AI systems and ROS 2-based humanoid robots. By creating publishers and subscribers, AI agents can:

- Receive sensor data for decision making
- Send motion commands to robot controllers
- Implement complex behaviors using the AI-to-ROS control bridge pattern
- Integrate with machine learning frameworks for intelligent control

This integration is crucial for creating autonomous humanoid robots that can perceive, reason, and act in the physical world.

## References

- rclpy Documentation: https://docs.ros.org/en/humble/p/rclpy/
- ROS 2 Python Client Library: https://github.com/ros2/rclpy
- ROS 2 Tutorials for Python: https://docs.ros.org/en/humble/Tutorials/Beginner-Client-Libraries/Writing-A-Simple-Py-Publisher-And-Subscriber.html