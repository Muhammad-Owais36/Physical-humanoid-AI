---
title: Digital Twin Fundamentals - Gazebo & Unity
sidebar_position: 1
---

# Digital Twin Fundamentals: Gazebo & Unity

## Learning Objectives

By the end of this chapter, you will be able to:
- Understand the concept of Digital Twins in robotics and their importance
- Compare and contrast Gazebo and Unity as simulation platforms
- Set up basic simulation environments in both Gazebo and Unity
- Create simple robot models for simulation
- Understand the role of Digital Twins in humanoid robotics development

## Prerequisites

Before starting this chapter, you should have:
- Basic understanding of robotics concepts
- Familiarity with 3D modeling concepts
- Understanding of basic physics principles
- Access to a Linux-based system for Gazebo and Windows/Mac for Unity

## Introduction to Digital Twins in Robotics

A Digital Twin is a virtual representation of a physical system that serves as a real-time digital counterpart. In robotics, Digital Twins play a crucial role in:

- **Development**: Testing algorithms without physical hardware
- **Validation**: Verifying robot behaviors in safe environments
- **Training**: Training AI models before deployment on physical robots
- **Optimization**: Improving robot performance through virtual experimentation

For humanoid robotics, Digital Twins are particularly valuable because:
- Humanoid robots are expensive and complex
- Physical testing can be dangerous
- Many parameters need tuning before physical deployment
- Training for complex behaviors requires extensive data

## Gazebo: Open-Source Physics Simulation

Gazebo is an open-source physics simulation engine that has become the de facto standard for robotics simulation, particularly in the ROS ecosystem.

### Key Features of Gazebo

1. **Physics Engine**: Supports multiple physics engines (ODE, Bullet, SimBody)
2. **Sensor Simulation**: Realistic simulation of cameras, LiDAR, IMUs, and other sensors
3. **ROS Integration**: Seamless integration with ROS/ROS2 communication
4. **Plugin Architecture**: Extensible through custom plugins
5. **Large Model Database**: Access to the Gazebo Model Database

### Gazebo Architecture

Gazebo consists of several key components:

- **Gazebo Server**: The core physics simulation engine
- **Gazebo Client**: The visualization interface
- **Gazebo Plugins**: Extensions that provide specific functionality
- **Model Database**: Repository of robot and environment models

### Installing Gazebo

For ROS 2 Humble, install Gazebo Garden (the recommended version):

```bash
# Add Gazebo repository
sudo apt update && sudo apt install wget
wget https://packages.osrfoundation.org/gazebo.gpg -O /usr/share/keyrings/gazebo-archive-keyring.gpg
echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/gazebo-archive-keyring.gpg] http://packages.osrfoundation.org/gazebo/ubuntu-stable $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/gazebo.list > /dev/null

sudo apt update
sudo apt install gz-garden
```

## Unity: High-Fidelity Graphics Simulation

Unity is a commercial game engine that has found significant adoption in robotics simulation, particularly for applications requiring high-fidelity graphics and realistic rendering.

### Key Features of Unity for Robotics

1. **Photorealistic Rendering**: High-quality graphics for visual perception training
2. **XR Support**: Virtual and augmented reality capabilities
3. **Large Asset Store**: Extensive library of 3D models and environments
4. **C# Programming**: Familiar development environment for many developers
5. **Cross-Platform**: Deploy to multiple platforms and devices

### Unity Robotics Setup

Unity provides the Unity Robotics Hub for easier setup:

1. Install Unity Hub from the Unity website
2. Install Unity Editor (2021.3 LTS or later recommended)
3. Install Unity Robotics packages through Unity Registry
4. Set up ROS-TCP-Connector for ROS communication

## Creating Your First Robot Model

### URDF to SDF Conversion

Most robotics work uses URDF (Unified Robot Description Format) for robot models. Gazebo uses SDF (Simulation Description Format), but can load URDF directly:

```xml
<!-- Example URDF for a simple humanoid robot -->
<?xml version="1.0"?>
<robot name="simple_humanoid">
  <!-- Base link -->
  <link name="base_link">
    <visual>
      <geometry>
        <box size="0.3 0.2 0.1"/>
      </geometry>
      <material name="blue">
        <color rgba="0 0 1 1"/>
      </material>
    </visual>
    <collision>
      <geometry>
        <box size="0.3 0.2 0.1"/>
      </geometry>
    </collision>
    <inertial>
      <mass value="5.0"/>
      <inertia ixx="0.1" ixy="0" ixz="0" iyy="0.1" iyz="0" izz="0.1"/>
    </inertial>
  </link>

  <!-- Head -->
  <joint name="head_joint" type="fixed">
    <parent link="base_link"/>
    <child link="head"/>
    <origin xyz="0 0 0.15" rpy="0 0 0"/>
  </joint>

  <link name="head">
    <visual>
      <geometry>
        <sphere radius="0.1"/>
      </geometry>
      <material name="white">
        <color rgba="1 1 1 1"/>
      </material>
    </visual>
    <collision>
      <geometry>
        <sphere radius="0.1"/>
      </geometry>
    </collision>
    <inertial>
      <mass value="1.0"/>
      <inertia ixx="0.01" ixy="0" ixz="0" iyy="0.01" iyz="0" izz="0.01"/>
    </inertial>
  </link>

  <!-- Left arm -->
  <joint name="left_shoulder_joint" type="revolute">
    <parent link="base_link"/>
    <child link="left_upper_arm"/>
    <origin xyz="0.15 0 0.05" rpy="0 0 0"/>
    <axis xyz="0 1 0"/>
    <limit lower="-1.57" upper="1.57" effort="100" velocity="1.0"/>
  </joint>

  <link name="left_upper_arm">
    <visual>
      <geometry>
        <cylinder length="0.3" radius="0.05"/>
      </geometry>
      <material name="gray">
        <color rgba="0.5 0.5 0.5 1"/>
      </material>
    </visual>
    <collision>
      <geometry>
        <cylinder length="0.3" radius="0.05"/>
      </geometry>
    </collision>
    <inertial>
      <mass value="1.0"/>
      <inertia ixx="0.01" ixy="0" ixz="0" iyy="0.01" iyz="0" izz="0.01"/>
    </inertial>
  </link>

  <!-- Additional links and joints would continue here -->

  <!-- Gazebo-specific extensions -->
  <gazebo reference="base_link">
    <material>Gazebo/Blue</material>
  </gazebo>

  <gazebo reference="head">
    <material>Gazebo/White</material>
  </gazebo>

  <gazebo>
    <plugin name="joint_state_publisher" filename="libgazebo_ros_joint_state_publisher.so">
      <ros>
        <namespace>/simple_humanoid</namespace>
      </ros>
      <update_rate>30</update_rate>
      <joint_name>head_joint</joint_name>
    </plugin>
  </gazebo>

</robot>
```

### Launching Gazebo with Your Robot

Create a launch file to spawn your robot in Gazebo:

```python
# launch/simple_humanoid_gazebo.launch.py
from launch import LaunchDescription
from launch.actions import DeclareLaunchArgument, IncludeLaunchDescription
from launch.launch_description_sources import PythonLaunchDescriptionSource
from launch.substitutions import LaunchConfiguration, PathJoinSubstitution
from launch_ros.actions import Node
from launch_ros.substitutions import FindPackageShare

def generate_launch_description():
    # Declare arguments
    declared_arguments = []
    declared_arguments.append(
        DeclareLaunchArgument(
            "use_sim_time",
            default_value="true",
            description="If true, use simulated time",
        )
    )

    # Get configurations
    use_sim_time = LaunchConfiguration("use_sim_time")

    # Get URDF file path
    urdf_file = PathJoinSubstitution(
        [FindPackageShare("humanoid_description"), "urdf", "simple_humanoid.urdf"]
    )

    # Read URDF file
    with open(urdf_file.perform({}), 'r') as infp:
        robot_description_content = infp.read()

    robot_description = {"robot_description": robot_description_content}

    # Gazebo server
    gazebo_server = IncludeLaunchDescription(
        PythonLaunchDescriptionSource(
            PathJoinSubstitution(
                [FindPackageShare("gazebo_ros"), "launch", "gzserver.launch.py"]
            )
        ),
        launch_arguments={"verbose": "false"}.items(),
    )

    # Gazebo client
    gazebo_client = IncludeLaunchDescription(
        PythonLaunchDescriptionSource(
            PathJoinSubstitution(
                [FindPackageShare("gazebo_ros"), "launch", "gzclient.launch.py"]
            )
        ),
    )

    # Robot state publisher
    robot_state_publisher = Node(
        package="robot_state_publisher",
        executable="robot_state_publisher",
        output="both",
        parameters=[robot_description, {"use_sim_time": use_sim_time}],
    )

    # Spawn entity
    spawn_entity = Node(
        package="gazebo_ros",
        executable="spawn_entity.py",
        arguments=[
            "-topic", "robot_description",
            "-entity", "simple_humanoid",
            "-x", "0.0",
            "-y", "0.0",
            "-z", "0.5"
        ],
        output="screen",
    )

    return LaunchDescription(
        declared_arguments +
        [
            gazebo_server,
            gazebo_client,
            robot_state_publisher,
            spawn_entity,
        ]
    )
```

## Unity Robotics Simulation

Unity provides the Unity Robotics Simulation package for creating high-fidelity robotics simulations.

### Setting up Unity for Robotics

1. Create a new 3D project in Unity
2. Install the Unity Robotics packages from the Package Manager:
   - Unity Robotics Hub
   - Unity Simulation for Robotics
   - ROS-TCP-Connector

### Basic Unity Robotics Scene Setup

In Unity, you would typically:

1. Create a robot model using 3D primitives or imported assets
2. Add colliders and rigidbodies for physics simulation
3. Implement ROS communication using the ROS-TCP-Connector
4. Set up sensors (cameras, LiDAR) with appropriate parameters

Example C# script for basic ROS communication:

```csharp
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Unity.Robotics.ROSTCPConnector;
using RosMessageTypes.Sensor;
using RosMessageTypes.Geometry;

public class UnityRobotController : MonoBehaviour
{
    ROSConnection ros;
    string rosTopicName = "joint_states";

    // Robot joint transforms
    public Transform headJoint;
    public Transform leftShoulderJoint;
    public Transform leftElbowJoint;

    // Start is called before the first frame update
    void Start()
    {
        // Get the ROS connection static instance
        ros = ROSConnection.GetOrCreateInstance();
        ros.RegisterPublisher<JointStateMsg>(rosTopicName);
    }

    // Update is called once per frame
    void Update()
    {
        // Create and publish joint state message
        var jointState = new JointStateMsg();
        jointState.name = new string[] { "head_joint", "left_shoulder_joint", "left_elbow_joint" };
        jointState.position = new double[] {
            headJoint.localEulerAngles.y * Mathf.Deg2Rad,
            leftShoulderJoint.localEulerAngles.y * Mathf.Deg2Rad,
            leftElbowJoint.localEulerAngles.y * Mathf.Deg2Rad
        };
        jointState.header.stamp = new TimeStamp(0, 0);
        jointState.header.frame_id = "base_link";

        // Publish the message
        ros.Publish(rosTopicName, jointState);
    }
}
```

## Comparing Gazebo and Unity for Digital Twins

| Aspect | Gazebo | Unity |
|--------|--------|-------|
| **Physics Accuracy** | High, research-grade | Good, game-engine based |
| **Graphics Quality** | Moderate | High, photorealistic |
| **ROS Integration** | Native, extensive | Through ROS-TCP-Connector |
| **Cost** | Free and open-source | Commercial license required |
| **Learning Curve** | Moderate for robotics | Steep for non-game developers |
| **Community** | Large robotics community | Large game development community |
| **Sensor Simulation** | Comprehensive | Good with plugins |
| **Performance** | Optimized for physics | Optimized for graphics |

## Digital Twin Workflow

The typical Digital Twin workflow for humanoid robotics includes:

1. **Model Creation**: Create accurate 3D models of the physical robot
2. **Physics Calibration**: Tune physics parameters to match real-world behavior
3. **Sensor Simulation**: Configure virtual sensors to match physical ones
4. **Algorithm Development**: Develop and test algorithms in simulation
5. **Transfer Learning**: Apply lessons learned to physical robot
6. **Iterative Improvement**: Refine both simulation and physical systems

## Integration with ROS 2

Both Gazebo and Unity can integrate with ROS 2:

### Gazebo-ROS 2 Integration

Gazebo has native ROS 2 support through the `gazebo_ros` packages:

```xml
<!-- In your URDF -->
<gazebo>
  <plugin filename="libgazebo_ros_joint_state_publisher.so" name="joint_state_publisher">
    <ros>
      <namespace>/simple_humanoid</namespace>
    </ros>
    <update_rate>30</update_rate>
    <joint_name>head_joint</joint_name>
  </plugin>
</gazebo>
```

### Unity-ROS 2 Integration

Unity uses TCP/IP communication to interface with ROS 2:

```bash
# Start the ROS-TCP-Endpoint
ros2 run ros_tcp_endpoint default_server_endpoint --ros-args -p ROS_IP:=127.0.0.1 -p ROS_TCP_PORT:=10000
```

## Best Practices for Digital Twin Development

### Model Accuracy
- Ensure physical properties match the real robot
- Calibrate mass, inertia, and friction parameters
- Validate sensor models against real hardware

### Performance Optimization
- Simplify collision geometry where possible
- Use appropriate update rates for different components
- Implement level-of-detail systems for complex scenes

### Validation Strategies
- Compare simulation and real-world behavior
- Use identical control algorithms in both environments
- Regularly update simulation parameters based on physical testing

## Summary

Digital Twins using Gazebo and Unity provide essential capabilities for humanoid robotics development. Gazebo excels in physics accuracy and ROS integration, while Unity provides high-fidelity graphics for perception training. Both platforms enable safe, cost-effective development and testing of complex humanoid robot behaviors.

The choice between platforms depends on your specific requirements: use Gazebo for physics-focused development and Unity for perception and visualization tasks.

## Next Steps

- Install and experiment with both Gazebo and Unity
- Create your first robot model in both environments
- Set up basic ROS communication
- Explore the Gazebo Model Database and Unity Asset Store
- Practice converting between URDF and Unity formats